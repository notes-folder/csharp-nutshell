#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"}]}}

#!csharp

/*
    4.13.1 静态绑定与动态绑定
    典型的绑定例子是在编译表达式时将一个名称映射到一个具体的函数上。
*/

// 如果要编译如下的表达式，那么编译器需要找到Quack方法的实现：
// d.Quack();

//假设d的静态类型为Duck：
// Duck d = ...
// d.Quack();

/*
    最简单的情况是编译器找到Duck中无参数的Quack方法进行绑定。
    如果绑定失败，则编译器会将搜索范围扩大到具有可选参数的方法，Duck的基类的方法和将Duck作为第一个参数的扩展方法。
    如果还是没有找到匹配的方法，那么将发生一个编译错误。
    无论绑定的是什么样的方法，都必须是由编译器编译的，而且完全依赖于之前已经知道的操作数（这里是d）类型。这就是所谓的静态绑定。
*/

#!csharp

// 现在我们将d的静态类型改为object：
// object d = ...
// d.Quack();

/*
    调用Quack时，我们会遇到一个编译错误，
    因为虽然存储在d中的值包含了一个名为Quack的方法，但是编译器无法得知，
    因为编译器所知的所有信息只是变量的类型（这里是object）。
*/

// 现在我们来将d的静态类型改为dynamic：
// dynamic d = ...
// d.Quack();

/*
    dynamic类型类似于object，即一种同样不具备描述性的类型。
    但区别是动态类型能够在编译时在不知道它存在的情况下使用它。
    动态对象是基于其运行时类型而非它的编译时类型进行绑定的。
    当编译器遇到一个动态绑定表达式时（通常是一个包含任意dynamic类型值的表达式），它仅仅对表达式进行打包，而绑定则在后面运行时执行。
*/

#!csharp

/*
    在运行时，如果一个动态对象实现了IDynamicMetaObjectProvider，那么这个接口将用来执行绑定。否则，绑定的发生方式几乎像是编译器已经事先知道动态对象的运行时类型一样。
    我们将这两种方式称为：自定义绑定和语言绑定。
    🍦 COM互操作可以认为是第三种动态绑定方式（见第25章）。
*/
