#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"}]}}

#!csharp

/*
    4.13.3 语言绑定
    语言绑定是在一个动态对象未实现IDynamicMetaObjectProvider时发生的。
    语言绑定在处理设计不当的类型或绕过.NET本身类型系统的限制时是非常有用的（我们将在第20章详细介绍）。
*/

// 例如，使用数字类型的一个常见问题是它没有通用接口。但是方法是可以动态绑定的，运算符也一样：
dynamic Mean(dynamic x, dynamic y) => (x + y) / 2;

int x = 3, y = 4;
Console.WriteLine(Mean(x, y));

/*
    其明显的好处是，不需要重复处理每种数值类型。
    然而这样做失去了静态类型安全性的保护，因此更可能发生运行时异常，而非编译时错误。
*/

#!csharp

/*
    🍦 动态绑定会损害静态类型安全性，但是不会影响运行时类型安全性。
    与反射机制（见第19章）不同，动态绑定不能绕过成员可访问性规则。
*/

/*
    从设计的角度，若动态对象的运行时类型在静态编译时已知，则语言的运行时绑定可以无限接近静态绑定的效果。
    在上述例子中，如果我们在Mean代码中直接处理int类型，那么程序的行为是相同的。
    静态和动态绑定最显著的差异在于扩展方法，我们将在4.13.11节进行介绍。
*/

/*
    🍦 动态绑定会对性能产生影响。
    然而，DLR的缓存机制对同一个动态表达式的重复调用进行了优化，允许在一个循环中高效地调用动态表达式。
    因此在如今的硬件条件下，一个简单的动态表达式的处理开销可以控制在100ns以内。
*/
