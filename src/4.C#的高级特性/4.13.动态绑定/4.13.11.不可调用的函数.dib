#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"}]}}

#!csharp

/*
    4.13.11 不可调用的函数
    有些函数无法动态调用，例如：
        · 扩展方法（通过扩展方法语法）
        · 必须将类型转换为接口才能调用的接口成员
        · 基类中被子类隐藏的成员理解其中的原因对于理解动态绑定是非常有帮助的。
*/

/*
    动态绑定需要两部分信息：调用的函数名和调用该函数的对象。
    但是在上述三种不可调用的情况中还涉及一个只在编译时可见的附加类型（additional type）。
    在C# 6中，我们是无法动态指定这种附加类型的。
*/

/*
    当调用扩展方法时，其附加类型是隐含的，即定义扩展方法的静态类。
    编译器会根据源代码中的using指令来搜索这个类。
    由于using指令在编译后（当它们在绑定过程中完成了将简单的名称映射到完整命名空间限定名称之后）就消失了，因而扩展方法是仅存在于编译时的概念。
*/

#!csharp

/*
    当通过接口调用成员时，需要通过一个隐式转换或显式转换来指定这个附加类型。
    有两种情况需要执行这个操作：
        调用显式实现的接口成员；
        或调用另一个程序集内部类型中实现的接口成员。
*/

// 以下示例中的两个类型展示了第一种情况：
interface IFoo { void Test(); }
class Foo : IFoo { void IFoo.Test() { } }

#!csharp

// 为了调用Test方法，我们必须将类型显式转换为IFoo接口。如果用静态方式则很简单：
IFoo f = new Foo();    // Implicit cast to interface
f.Test();

#!csharp

// 考虑如下动态类型的例子：
IFoo f = new Foo();
dynamic d = f;
d.Test();                // Exception thrown

#!csharp

/*
    我们用隐式转换（上面代码中加粗的部分）告知编译器将f的后续成员调用绑定到IFoo上而不是Foo上，换句话说，即通过IFoo接口的视角来查看对象。
    但是这个视角在运行时会消失，因此DLR无法完成这个绑定过程。
*/

// 消失的过程可以用如下的代码来展示：
Console.WriteLine(f.GetType().Name);     // Foo

//类似的情况也出现在调用隐藏的基类成员上：必须通过强制类型转换或者使用base关键字来指定一个附加类型，否则附加类型会在运行时消失。
